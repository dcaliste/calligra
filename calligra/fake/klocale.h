#ifndef FAKE_KLOCALE_H
#define FAKE_KLOCALE_H

#include <QString>
#include <QStringList>
#include <QObject>
#ifndef QT_NO_PRINTER
#include <QPrinter>
#endif
#include <QDate>
#include <QTime>
#include <QDateTime>
#include <QLocale>
#include <QCoreApplication>

#include <kdatetime.h>
#include <klocalizedstring.h>

class KCalendarSystem;

#if 0

#define I18N_NOOP(x) x
#define I18N_NOOP2(comment,x) x

class KLocale;


/**
 * Wraps KLocale to pure Qt the quick and dirty way to make it
 * easier to port KDE-applications to Qt-only and keeping both
 * versions working (what is especially interesting for
 * translations).
 */
class Q_DECL_EXPORT KLocalizedString {
public:
    KLocalizedString(const char *msg = "") : m_msg(msg) {
    }
    QString toString(KLocale *locale = 0) const {
        QString s = QObject::tr(m_msg);
        for(int i = 0; i < m_args.count(); ++i)
            s = s.arg(m_args[i]);
        return s;
    }
    QString toString(const QString&) { return toString(); }
    KLocalizedString subs(int a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
        Q_UNUSED(fieldWidth);
        Q_UNUSED(fillChar);
        KLocalizedString l(*this);
        l.m_args.append(QString::number(a, base, 'f'));
        return l;
    }
    KLocalizedString subs(uint a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
        Q_UNUSED(fieldWidth);
        Q_UNUSED(fillChar);
        KLocalizedString l(*this);
        l.m_args.append(QString::number(a, base, 'f'));
        return l;
    }
    KLocalizedString subs(long a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
        Q_UNUSED(fieldWidth);
        Q_UNUSED(fillChar);
        KLocalizedString l(*this);
        l.m_args.append(QString::number(a, base, 'f'));
        return l;
    }
    KLocalizedString subs(ulong a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
        Q_UNUSED(fieldWidth);
        Q_UNUSED(fillChar);
        KLocalizedString l(*this);
        l.m_args.append(QString::number(a, base, 'f'));
        return l;
    }
    KLocalizedString subs(qlonglong a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
        Q_UNUSED(fieldWidth);
        Q_UNUSED(fillChar);
        KLocalizedString l(*this);
        l.m_args.append(QString::number(a, base, 'f'));
        return l;
    }
    KLocalizedString subs(qulonglong a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
        Q_UNUSED(fieldWidth);
        Q_UNUSED(fillChar);
        KLocalizedString l(*this);
        l.m_args.append(QString::number(a, base, 'f'));
        return l;
    }
    KLocalizedString subs(double a, int fieldWidth = 0, char format = 'g', int precision = -1, const QChar &fillChar = QLatin1Char(' ')) const {
        Q_UNUSED(fieldWidth);
        Q_UNUSED(fillChar);
        KLocalizedString l(*this);
        l.m_args.append(QString::number(a, format, precision));
        return l;
    }
    KLocalizedString subs(QChar a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')) const {
        Q_UNUSED(fieldWidth);
        Q_UNUSED(fillChar);
        KLocalizedString l(*this);
        l.m_args.append(a);
        return l;
    }
    KLocalizedString subs(const QString &a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')) const {
        Q_UNUSED(fieldWidth);
        Q_UNUSED(fillChar);
        KLocalizedString l(*this);
        l.m_args.append(a);
        return l;
    }
private:
    const char *m_msg;
    QStringList m_args;
};

inline KLocalizedString ki18n (const char* msg) {
    return KLocalizedString(msg);
}
inline KLocalizedString ki18nc (const char *ctxt, const char *msg) {
    Q_UNUSED(ctxt);
    return KLocalizedString(msg);
}
inline KLocalizedString ki18np (const char *singular, const char *plural) {
    Q_UNUSED(singular);
    return KLocalizedString(plural);
}
inline KLocalizedString ki18ncp (const char *ctxt, const char *singular, const char *plural) {
    Q_UNUSED(ctxt);
    Q_UNUSED(singular);
    return KLocalizedString(plural);
}

// >>>>> Basic calls
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string.
 * @param text string to be localized
 * @return localized string
 */
inline QString i18n (const char *text)
{
  return ki18n(text).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 1 argument.
 * @param text string to be localized
 * @param a1 first argument
 * @return localized string
 */
template <typename A1>
inline QString i18n (const char *text, const A1 &a1)
{
  return ki18n(text).subs(a1).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 2 arguments.
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @return localized string
 */
template <typename A1, typename A2>
inline QString i18n (const char *text, const A1 &a1, const A2 &a2)
{
  return ki18n(text).subs(a1).subs(a2).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 3 arguments.
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3>
inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3)
{
  return ki18n(text).subs(a1).subs(a2).subs(a3).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 4 arguments.
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4>
inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
{
  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 5 arguments.
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5>
inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
{
  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 6 arguments.
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
{
  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 7 arguments.
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
{
  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 8 arguments.
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @param a8 eighth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
{
  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 9 arguments.
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @param a8 eighth argument
 * @param a9 ninth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
{
  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).subs(a9).toString();
}
// <<<<<<< End of basic calls

// >>>>> Context calls
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @return localized string
 */
inline QString i18nc (const char *ctxt, const char *text)
{
  return ki18nc(ctxt, text).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 1 argument and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @param a1 first argument
 * @return localized string
 */
template <typename A1>
inline QString i18nc (const char *ctxt, const char *text, const A1 &a1)
{
  return ki18nc(ctxt, text).subs(a1).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 2 arguments and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @return localized string
 */
template <typename A1, typename A2>
inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2)
{
  return ki18nc(ctxt, text).subs(a1).subs(a2).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 3 arguments and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3>
inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3)
{
  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 4 arguments and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4>
inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
{
  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 5 arguments and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5>
inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
{
  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 6 arguments and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
{
  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 7 arguments and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
{
  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 8 arguments and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @param a8 eighth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
{
  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 9 arguments and a context.
 * @param ctxt context of the string
 * @param text string to be localized
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @param a8 eighth argument
 * @param a9 ninth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
{
  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).subs(a9).toString();
}
// <<<<< End of context calls

// >>>>> Plural calls
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 1 argument using correct plural form.
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @return localized string
 */
template <typename A1>
inline QString i18np (const char *sing, const char *plur, const A1 &a1)
{
  return ki18np(sing, plur).subs(a1).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 2 arguments using correct plural form.
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @return localized string
 */
template <typename A1, typename A2>
inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2)
{
  return ki18np(sing, plur).subs(a1).subs(a2).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 3 arguments using correct plural form.
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3>
inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3)
{
  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 4 arguments using correct plural form.
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4>
inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
{
  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 5 arguments using correct plural form.
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5>
inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
{
  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 6 arguments using correct plural form.
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
{
  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 7 arguments using correct plural form.
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
{
  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 8 arguments using correct plural form.
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @param a8 eighth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
{
  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 9 arguments using correct plural form.
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @param a8 eighth argument
 * @param a9 ninth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
{
  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).subs(a9).toString();
}
// <<<<< End of plural calls

// >>>>> Context-plural calls
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 1 argument and a context using correct plural form.
 * @param ctxt context of the string
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @return localized string
 */
template <typename A1>
inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1)
{
  return ki18ncp(ctxt, sing, plur).subs(a1).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 2 arguments and a context using correct plural form.
 * @param ctxt context of the string
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @return localized string
 */
template <typename A1, typename A2>
inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2)
{
  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 3 arguments and a context using correct plural form.
 * @param ctxt context of the string
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3>
inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3)
{
  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 4 arguments and a context using correct plural form.
 * @param ctxt context of the string
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4>
inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
{
  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 5 arguments and a context using correct plural form.
 * @param ctxt context of the string
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5>
inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
{
  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 6 arguments and a context using correct plural form.
 * @param ctxt context of the string
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
{
  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 7 arguments and a context using correct plural form.
 * @param ctxt context of the string
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
{
  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 8 arguments and a context using correct plural form.
 * @param ctxt context of the string
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @param a8 eighth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
{
  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).toString();
}
// Autogenerated; contact KLocalizedString maintainer for batch changes.
/**
 * Returns a localized version of a string with 9 arguments and a context using correct plural form.
 * @param ctxt context of the string
 * @param sing string to be localized in singular
 * @param plur string to be localized in plural
 * @param a1 first argument
 * @param a2 second argument
 * @param a3 third argument
 * @param a4 fourth argument
 * @param a5 fifth argument
 * @param a6 sixth argument
 * @param a7 seventh argument
 * @param a8 eighth argument
 * @param a9 ninth argument
 * @return localized string
 */
template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
{
  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).subs(a9).toString();
}
// <<<<< End of context-plural calls
#endif

class Q_DECL_EXPORT KLocale {
public:
    KLocale(const QByteArray &name = QByteArray());
    KLocale(KCalendarSystem *calendar, const QByteArray &name = QByteArray());
    ~KLocale();

    //QString formatNumber(double num, int precision = -1) const { return m_locale.toString(num); }
    //QString formatNumber(const QString &numStr, bool round = true, int precision = -1) const { return m_locale.toString(num); }
    //QString formatLong(long num) const { return m_locale.toString(num); }
    static QString formatNumber(double num, int precision = -1) { return QString::number(num, 'f', precision); }
    QString formatNumber(const QString &numStr, bool round = true, int precision = -1) const { return formatNumber(numStr.toDouble(), precision); }
    QString formatLong(long num) const { return m_locale.toString((qlonglong)num); }

    double readNumber(const QString &numStr, bool * ok = 0) const
    {
        return numStr.toDouble(ok);
    }

    QString decimalSymbol() const
    {
        return ".";
    }
    QString thousandsSeparator() const
    {
        return ",";
    }

    QString currencySymbol() const
    {
        return QLatin1String("$");
    }

//    QString formatMoney(double num, const QString &currency = QString(), int precision = -1) const
//        { return m_locale.toCurrencyString(num, currency); }
    QString formatMoney(double num, const QString &currency = QString(), int precision = -1) const
    {
        QString res = QString::number(num, 'f', precision);
        if (!currency.isEmpty())
            res += " " + currency;
        return res;
    }

    int pageSize() const
    {
#ifndef QT_NO_PRINTER
        return QPrinter::A4;
#else
        return 0;
#endif
    }
#if 0
    /**
    * Constructs a KLocale with the given catalog name
    *
    * The constructor looks for an entry Language in the group Locale in the
    * configuration file.
    *
    * If no configuration file is specified, it will also look for languages
    * using the environment variables (KDE_LANG, LC_MESSAGES, LC_ALL, LANG),
    * as well as the global configuration file. If KLocale is not able to use
    * any of the specified languages, the default language (en_US) will be
    * used.
    *
    * If you specify a configuration file, it has to be valid until the KLocale
    * object is destroyed.  Note that a setLocale() will be performed on the
    * config using the current locale language, which may cause a sync()
    * and reparseConfiguration() which will save any changes you have made and
    * load any changes other shared copies have made.
    *
    * @param catalog the name of the main language file
    * @param config  a configuration file with a Locale group detailing
    *                locale-related preferences (such as language and
    *                formatting options).
    */
    explicit KLocale(const QString& catalog, KSharedConfig::Ptr config = KSharedConfig::Ptr());

    /**
    * Constructs a KLocale with the given catalog name
    *
    * Allows you to override the language and, optionally, the
    * country of this locale.
    *
    * If you specify a configuration file, a setLocale() will be performed on
    * the config using the current locale language, which may cause a sync()
    * and reparseConfiguration() which will save any changes you have made.
    *
    * @param catalog  the name of the main language file
    * @param language the ISO Language Code for the locale, e.g. "en" for English
    * @param country  the ISO Country Code for the locale, e.g. "us" for USA
    * @param config   a configuration file with a Locale group detailing
    *                 locale-related preferences (such as language and
    *                 formatting options).
    */
    KLocale(const QString& catalog, const QString &language, const QString &country = QString(),
            KConfig *config = 0);

    /**
    * Copy constructor
    */
    KLocale(const KLocale & rhs);

    /**
    * Assignment operator
    */
    KLocale& operator= (const KLocale & rhs);

    /**
    * Destructor
    */
    virtual ~KLocale();

    /**
    * @since 4.5
    *
    * Raw translation from a message catalog.
    * If catalog name is null or empty,
    * all loaded catalogs are searched for the translation.
    *
    * Never use this directly to get message translations. See the i18n and ki18n
    * family of calls related to KLocalizedString.
    *
    * @param catname the catalog name. Must be UTF-8 encoded.
    * @param msg the message. Must not be null or empty. Must be UTF-8 encoded.
    * @param lang language in which the translation was found. If no translation
    *             was found, KLocale::defaultLanguage() is reported. If null,
    *             the language is not reported.
    * @param trans raw translation, or original if not found. If no translation
    *              was found, original message is reported. If null, the
    *              translation is not reported.
    *
    * @see KLocalizedString
    */
    void translateRawFrom(const char* catname, const char* msg, QString *lang, QString *trans) const;

    /**
    * Like translateRawFrom, with implicit lookup through all loaded catalogs.
    *
    * @deprecated Use translateRawFrom with null or empty catalog name.
    */
    void translateRaw(const char* msg, QString *lang, QString *trans) const;

    /**
    * @since 4.5
    *
    * Raw translation from a message catalog, with given context.
    * Context + message are used as the lookup key in the catalog.
    * If catalog name is null or empty,
    * all loaded catalogs are searched for the translation.
    *
    * Never use this directly to get message translations. See i18n* and ki18n*
    * calls related to KLocalizedString.
    *
    * @param catname the catalog name. Must be UTF-8 encoded.
    * @param ctxt the context. Must not be null. Must be UTF-8 encoded.
    * @param msg the message. Must not be null or empty. Must be UTF-8 encoded.
    * @param lang language in which the translation was found. If no translation
    *             was found, KLocale::defaultLanguage() is reported. If null,
    *             the language is not reported.
    * @param trans raw translation, or original if not found. If no translation
    *              was found, original message is reported. If null, the
    *              translation is not reported.
    *
    * @see KLocalizedString
    */
    void translateRawFrom(const char *catname, const char *ctxt, const char *msg, QString *lang, QString *trans) const;

    /**
    * Like translateRawFrom, with implicit lookup through all loaded catalogs.
    *
    * @deprecated Use translateRawFrom with null or empty catalog name.
    */
    void translateRaw(const char *ctxt, const char *msg, QString *lang, QString *trans) const;

    /**
    * @since 4.5
    *
    * Raw translation from a message catalog, with given singular/plural form.
    * Singular form is used as the lookup key in the catalog.
    * If catalog name is null or empty,
    * all loaded catalogs are searched for the translation.
    *
    * Never use this directly to get message translations. See i18n* and ki18n*
    * calls related to KLocalizedString.
    *
    * @param catname the catalog name. Must be UTF-8 encoded.
    * @param singular the singular form. Must not be null or empty. Must be UTF-8 encoded.
    * @param plural the plural form. Must not be null. Must be UTF-8 encoded.
    * @param n number on which the forms are decided.
    * @param lang language in which the translation was found. If no translation
    *             was found, KLocale::defaultLanguage() is reported. If null,
    *             the language is not reported.
    * @param trans raw translation, or original if not found. If no translation
    *              was found, original message is reported (either plural or
    *              singular, as determined by @p n ). If null, the
    *              translation is not reported.
    *
    * @see KLocalizedString
    */
    void translateRawFrom(const char *catname, const char *singular, const char *plural,  unsigned long n,
                            QString *lang, QString *trans) const;

    /**
    * Like translateRawFrom, with implicit lookup through all loaded catalogs.
    *
    * @deprecated Use translateRawFrom with null or empty catalog name.
    */
    void translateRaw(const char *singular, const char *plural,  unsigned long n, QString *lang,
                    QString *trans) const;

    /**
    * @since 4.5
    *
    * Raw translation from a message catalog, with given context and
    * singular/plural form.
    * Context + singular form is used as the lookup key in the catalog.
    * If catalog name is null or empty,
    * all loaded catalogs are searched for the translation.
    *
    * Never use this directly to get message translations. See i18n* and ki18n*
    * calls related to KLocalizedString.
    *
    * @param catname the catalog name. Must be UTF-8 encoded.
    * @param ctxt the context. Must not be null. Must be UTF-8 encoded.
    * @param singular the singular form. Must not be null or empty. Must be UTF-8 encoded.
    * @param plural the plural form. Must not be null. Must be UTF-8 encoded.
    * @param n number on which the forms are decided.
    * @param lang language in which the translation was found. If no translation
    *             was found, KLocale::defaultLanguage() is reported. If null,
    *             the language is not reported.
    * @param trans raw translation, or original if not found. If no translation
    *              was found, original message is reported (either plural or
    *              singular, as determined by @p n ). If null, the
    *              translation is not reported.
    *
    * @see KLocalizedString
    */
    void translateRawFrom(const char *catname, const char *ctxt, const char *singular, const char *plural,
                            unsigned long n, QString *lang, QString *trans) const;

    /**
    * Like translateRawFrom, with implicit lookup through all loaded catalogs.
    *
    * @deprecated Use translateRawFrom with null or empty catalog name.
    */
    void translateRaw(const char *ctxt, const char *singular, const char *plural, unsigned long n,
                    QString *lang, QString *trans) const;

    /**
    * Changes the current encoding.
    *
    * @param mibEnum The mib of the preferred codec
    *
    * @return True on success.
    */
    bool setEncoding(int mibEnum);
#endif

    enum SignPosition {
        /**
        * Put parantheses around the quantity, e.g. "$ (217)"
        */
        ParensAround = 0,
        /**
        * Prefix the quantity with the sign, e.g. "$ -217"
        */
        BeforeQuantityMoney = 1,
        /**
        * Suffix the quanitity with the sign, e.g. "$ 217-"
        */
        AfterQuantityMoney = 2,
        /**
        * Prefix the currency symbol with the sign, e.g. "-$ 217"
        */
        BeforeMoney = 3,
        /**
        * Suffix the currency symbol with the sign, e.g. "$- 217"
        */
        AfterMoney = 4
    };

    enum DigitSet {
        ArabicDigits,             /**< 0123456789 (European and some Asian
                                    languages and western Arabic dialects) */
        ArabicIndicDigits,        /**< ٠١٢٣٤٥٦٧٨٩ (eastern Arabic dialects) */
        EasternArabicIndicDigits, /**< ۰۱۲۳۴۵۶۷۸۹ (Persian and Urdu) */
        DevenagariDigits,         /**< ०१२३४५६७८९ (Hindi) */
        BengaliDigits,            /**< ০১২৩৪৫৬৭৮৯ (Bengali and  Assamese) */
        GujaratiDigits,           /**< ૦૧૨૩૪૫૬૭૮૯ (Gujarati) */
        GurmukhiDigits,           /**< ੦੧੨੩੪੫੬੭੮੯ (Punjabi) */
        KannadaDigits,            /**< ೦೧೨೩೪೫೬೭೮೯ (Kannada) */
        KhmerDigits,              /**< ០១២៣៤៥៦៧៨៩ (Khmer) */
        MalayalamDigits,          /**< ൦൧൨൩൪൫൬൭൮൯ (Malayalam) */
        OriyaDigits,              /**< ୦୧୨୩୪୫୬୭୮୯ (Oriya) */
        TamilDigits,              /**< ௦௧௨௩௪௫௬௭௮ (Tamil) */
        TeluguDigits,             /**< ౦౧౨౩౪౫౬౭౯ (Telugu) */
        ThaiDigits                /**< ๐๑๒๓๔๕๖๗๘๙ (Thai) */
    // The following Decimal Digit Sets are defined in Unicode but the associated
    // languages are not yet translated in KDE, so are not yet enabled.
    // The script names are taken from the Unicode standard, the associated
    // languages from Wikipedia.
    //  BalineseDigits,           /**< ᭐᭑᭒᭓᭔᭕᭖᭗᭘᭙ (Balinese) */
    //  ChamDigits,               /**< ꩐꩑꩒꩓꩔꩕꩖꩗꩘꩙ (Cham) */
    //  JavaneseDigits,           /**< ꧐꧑꧒꧓꧔꧕꧖꧗꧘꧙ (Javanese) */
    //  KayahLiDigits,            /**< ꤀꤁꤂꤃꤄꤅꤆꤇꤈꤉ (Kayah) */
    //  LaoDigits,                /**< ໐໑໒໓໔໕໖໗໘໙ (Lao) */
    //  LepchaDigits,             /**< ᱀᱁᱂᱃᱄᱅᱆᱇᱈᱉ (Lepcha) */
    //  LimbuDigits,              /**< ᥆᥇᥈᥉᥊᥋᥌᥍᥎᥏ (Limbu) */
    //  MeeteiMayekDigits,        /**< ꯰꯱꯲꯳꯴꯵꯶꯷꯸꯹ (Meitei) */
    //  MongolianDigits,          /**< ᠐᠑᠒᠓᠔᠕᠖᠗᠘᠙ (Mongolian) */
    //  MyanmarDigits,            /**< ၀၁၂၃၄၅၆၇၈၉ (Myanmar/Burmese ) */
    //  MyanmarShanDigits,        /**< ႐႑႒႓႔႕႖႗႘႙ (Shan) */
    //  NewTaiLueDigits,          /**< ᧐᧑᧒᧓᧔᧕᧖᧗᧘᧙ (Tai Lü) */
    //  NKoDigits,                /**< ߀߁߂߃߄߅߆߇߈߉ (Mande and N'Ko) */
    //  OlChikiDigits,            /**< ᱐᱑᱒᱓᱔᱕᱖᱗᱘᱙ (Santali) */
    //  OsmanyaDigits,            /**< ҠҡҢңҤҥҦҧҨҩ (Somali) */
    //  SaurashtraDigits,         /**< ꣐꣑꣒꣓꣔꣕꣖꣗꣘꣙ (Saurashtra) */
    //  SundaneseDigits,          /**< ᮰᮱᮲᮳᮴᮵᮶᮷᮸᮹ (Sundanese) */
    //  TaiThamDigits,            /**< ᪐᪑᪒᪓᪔᪕᪖᪗᪘᪙ (Tai Lü) */
    //  TibetanDigits,            /**< ༠༡༢༣༤༥༦༧༨༩ (Tibetan) */
    //  VaiDigits,                /**< ꘠꘡꘢꘣꘤꘥꘦꘧꘨꘩ (Vai) */
    };

#if 0
    /**
    * @since 4.3
    *
    * Convert a digit set identifier to a human readable, localized name.
    *
    * @param digitSet the digit set identifier
    * @param withDigits whether to add the digits themselves to the name
    *
    * @return the human readable and localized name of the digit set
    *
    * @see DigitSet
    */
    QString digitSetToName(DigitSet digitSet, bool withDigits = false) const;

    /**
    * @since 4.3
    *
    * Provides list of all known digit set identifiers.
    *
    * @return list of all digit set identifiers
    * @see DigitSet
    * @see digitSetToName
    */
    QList<DigitSet> allDigitSetsList() const;

    /**
    * @since 4.3
    *
    * Returns the identifier of the digit set used to display numbers.
    *
    * @return the digit set identifier
    * @see DigitSet
    * @see digitSetToName
    */
    DigitSet digitSet() const;

    /**
    * @since 4.4
    *
    * Returns the ISO 4217 Currency Code for the current locale
    *
    * @return The default ISO Currency Code used by locale.
    */
    QString currencyCode() const;

    /**
    * @since 4.4
    *
    * Returns the Currency Code object for the current locale
    *
    * @return The default Currency Code object used by locale.
    */
    KCurrencyCode *currency() const;
#endif

    QString monetaryDecimalSymbol() const { return m_locale.decimalPoint(); }
    QString monetaryThousandsSeparator() const { return m_locale.groupSeparator(); }
    QString positiveSign() const { return m_locale.positiveSign(); }
    QString negativeSign() const { return m_locale.negativeSign(); }

    int fracDigits() const { return decimalPlaces(); }
    int decimalPlaces() const { return 2; }
    int monetaryDecimalPlaces() const { return 2; }

    bool positivePrefixCurrencySymbol() const { return true; }
    bool negativePrefixCurrencySymbol() const { return true; }
    SignPosition positiveMonetarySignPosition() const { return BeforeMoney; }
    SignPosition negativeMonetarySignPosition() const { return BeforeMoney; }

#if 0
    /**
    * @since 4.3
    *
    * Retuns the digit set used to display monetary values.
    *
    * @return the digit set identifier
    * @see DigitSet
    * @see digitSetToName
    */
    DigitSet monetaryDigitSet() const;

    /**
    * These binary units are used in KDE by the formatByteSize()
    * functions.
    *
    * NOTE: There are several different units standards:
    * 1) SI  (i.e. metric), powers-of-10.
    * 2) IEC, powers-of-2, with specific units KiB, MiB, etc.
    * 3) JEDEC, powers-of-2, used for solid state memory sizing which
    *    is why you see flash cards labels as e.g. 4GB.  These (ab)use
    *    the metric units.  Although JEDEC only defines KB, MB, GB, if
    *    JEDEC is selected all units will be powers-of-2 with metric
    *    prefixes for clarity in the event of sizes larger than 1024 GB.
    *
    * Although 3 different dialects are possible this enum only uses
    * metric names since adding all 3 different names of essentially the same
    * unit would be pointless.  Use BinaryUnitDialect to control the exact
    * units returned.
    *
    * @since 4.4
    * @see binaryUnitDialect
    */
    enum BinarySizeUnits {
        /// Auto-choose a unit such that the result is in the range [0, 1000 or 1024)
        DefaultBinaryUnits = -1,

        // The first real unit must be 0 for the current implementation!
        UnitByte,      ///<  B         1 byte
        UnitKiloByte,  ///<  KiB/KB/kB 1024/1000 bytes.
        UnitMegaByte,  ///<  MiB/MB/MB 2^20/10^06 bytes.
        UnitGigaByte,  ///<  GiB/GB/GB 2^30/10^09 bytes.
        UnitTeraByte,  ///<  TiB/TB/TB 2^40/10^12 bytes.
        UnitPetaByte,  ///<  PiB/PB/PB 2^50/10^15 bytes.
        UnitExaByte,   ///<  EiB/EB/EB 2^60/10^18 bytes.
        UnitZettaByte, ///<  ZiB/ZB/ZB 2^70/10^21 bytes.
        UnitYottaByte, ///<  YiB/YB/YB 2^80/10^24 bytes.
        UnitLastUnit = UnitYottaByte
    };

    /**
    * This enum chooses what dialect is used for binary units.
    *
    * Note: Although JEDEC abuses the metric prefixes and can therefore be
    * confusing, it has been used to describe *memory* sizes for quite some time
    * and programs should therefore use either Default, JEDEC, or IEC 60027-2
    * for memory sizes.
    *
    * On the other hand network transmission rates are typically in metric so
    * Default, Metric, or IEC (which is unambiguous) should be chosen.
    *
    * Normally choosing DefaultBinaryUnits is the best option as that uses
    * the user's selection for units.
    *
    * @since 4.4
    * @see binaryUnitDialect
    * @see setBinaryUnitDialect
    */
    enum BinaryUnitDialect {
        DefaultBinaryDialect = -1, ///< Used if no specific preference
        IECBinaryDialect,          ///< KDE Default, KiB, MiB, etc. 2^(10*n)
        JEDECBinaryDialect,        ///< KDE 3.5 default, KB, MB, etc. 2^(10*n)
        MetricBinaryDialect,       ///< SI Units, kB, MB, etc. 10^(3*n)
        LastBinaryDialect = MetricBinaryDialect
    };

    /**
    * Converts @p size from bytes to the string representation using the
    * user's default binary unit dialect.  The default unit dialect is
    * IEC 60027-2.
    *
    * Example:
    * formatByteSize(1024) returns "1.0 KiB" by default.
    *
    * @param  size  size in bytes
    * @return converted size as a string - e.g. 123.4 KiB , 12.0 MiB
    * @see BinaryUnitDialect
    * @todo KDE 5: Remove in favor of overload added in KDE 4.4.
    */
    QString formatByteSize(double size) const;

    /**
    * @since 4.4
    *
    * Converts @p size from bytes to the appropriate string representation
    * using the binary unit dialect @p dialect and the specific units @p specificUnit.
    *
    * Example:
    * formatByteSize(1000, unit, KLocale::BinaryUnitKilo) returns:
    *   for KLocale::MetricBinaryUnits, "1.0 kB",
    *   for KLocale::IECBinaryUnits,    "0.9 KiB",
    *   for KLocale::JEDECBinaryUnits,  "0.9 KB".
    *
    * @param size size in bytes
    * @param precision number of places after the decimal point to use.  KDE uses
    *        1 by default so when in doubt use 1.
    * @param dialect binary unit standard to use.  Use DefaultBinaryUnits to
    *        use the localized user selection unless you need to use a specific
    *        unit type (such as displaying a flash memory size in JEDEC).
    * @param specificUnit specific unit size to use in result.  Use
    *        DefaultBinarySize to automatically select a unit that will return
    *        a sanely-sized number.
    * @return converted size as a translated string including the units.
    *         E.g. "1.23 KiB", "2 GB" (JEDEC), "4.2 kB" (Metric).
    * @see BinaryUnitDialect
    */
    QString formatByteSize(double size, int precision,
                        BinaryUnitDialect dialect = KLocale::DefaultBinaryDialect,
                        BinarySizeUnits specificUnit = KLocale::DefaultBinaryUnits) const;

    /**
    * Returns the user's configured binary unit dialect.
    * e.g. if MetricBinaryDialect is returned then the values
    * configured for how much a set of bytes are worth would
    * be 10^(3*n) and KB (1000 bytes == 1 KB), in this case.
    *
    * Will never return DefaultBinaryDialect.
    *
    * @since 4.4
    * @return User's configured binary unit dialect
    * @see BinaryUnitDialect
    */
    BinaryUnitDialect binaryUnitDialect() const;

    /**
    * Sets @p newDialect to be the default dialect for this locale (and only
    * this locale).  Newly created KLocale objects will continue to default
    * to the user's choice.
    *
    * @param newDialect the new dialect to set as default for this locale object.
    * @since 4.4
    */
    void setBinaryUnitDialect(BinaryUnitDialect newDialect);

    /**
    * Given a number of milliseconds, converts that to a string containing
    * the localized equivalent
    *
    * e.g. given formatDuration(60000), returns "1.0 minutes"
    *
    * @param mSec Time duration in milliseconds
    * @return converted duration as a string - e.g. "5.5 seconds" "23.0 minutes"
    */
    QString formatDuration(unsigned long mSec) const;

    /**
    * Given a number of milliseconds, converts that to a pretty string containing
    * the localized equivalent.
    *
    * e.g. given prettyFormatDuration(60001) returns "1 minute"
    *      given prettyFormatDuration(62005) returns "1 minute and 2 seconds"
    *      given prettyFormatDuration(90060000) returns "1 day and 1 hour"
    *
    * @param mSec Time duration in milliseconds
    * @return converted duration as a string.
    *         Units not interesting to the user, for example seconds or minutes when the first
    *         unit is day, are not returned because they are irrelevant. The same applies for
    *         seconds when the first unit is hour.
    * @since 4.2
    */
    QString prettyFormatDuration(unsigned long mSec) const;

    /**
    * @deprecated
    *
    * Use this to determine whether nouns are declined in
    * locale's language. This property should remain
    * read-only (no setter function)
    *
    * @return If nouns are declined
    */
    KDE_DEPRECATED bool nounDeclension() const;
#endif

    enum CalendarSystem {
        QDateCalendar = 1, /**< KDE Default, hybrid of Gregorian and Julian as used by QDate */
        //BahaiCalendar = 2, /**< Baha'i Calendar */
        //BuddhistLunarCalendar = 3, /**< Buddhist Lunar Calendar*/
        //ChineseCalendar = 4, /**< Chinese Calendar */
        CopticCalendar = 5, /**< Coptic Calendar as used Coptic Church and some parts of Egypt */
        EthiopianCalendar = 6, /**< Ethiopian Calendar, aka Ethiopic Calendar */
        //EthiopianAmeteAlemCalendar = 7, /**< Ethiopian Amete Alem version, aka Ethiopic Amete Alem */
        GregorianCalendar = 8, /**< Gregorian Calendar, pure proleptic implementation */
        HebrewCalendar = 9, /**< Hebrew Calendar, aka Jewish Calendar */
        //HinduCalendar = 10, /**< Hindu Lunar Calendar */
        //IslamicLunarCalendar = 11, /**< Islamic Lunar Calendar */
        IslamicCivilCalendar = 12, /**< Islamic Civil Calendar, aka Hijri, not the Lunar Calendar */
        //IslamicUmAlQuraCalendar = 13, /**< Islamic Lunar Calendar, Um Al Qura varient used in Saudi Arabia */
        IndianNationalCalendar = 14, /**< Indian National Calendar, not the Lunar Calendar */
        //Iso8601Calendar = 15, /**< ISO 8601 Standard Calendar */
        JalaliCalendar = 16, /**< Jalali Calendar, aka Persian or Iranian, also used in Afghanistan */
        //JalaliBirashkCalendar = 17, /**< Jalali Calendar, Birashk Algorythm variant */
        //Jalali33YearCalendar = 18, /**< Jalali Calendar, 33 Year cycle variant */
        JapaneseCalendar= 19, /**< Japanese Calendar, Gregorian calculation using Japanese Era (Nengô) */
        //JucheCalendar = 20, /**< Juche Calendar, used in North Korea */
        JulianCalendar = 21, /**< Julian Calendar, as used in Orthodox Churches */
        MinguoCalendar= 22, /**< Minguo Calendar, aka ROC, Republic of China or Taiwanese */
        ThaiCalendar = 23 /**< Thai Calendar, aka Buddhist or Thai Buddhist */
    };

    enum WeekNumberSystem {
        DefaultWeekNumber = -1, /**< The system locale default */
        IsoWeekNumber     =  0, /**< ISO Week Number */
        FirstFullWeek     =  1, /**< Week 1 starts on the first Week Start Day in year ends after 7 days */
        FirstPartialWeek  =  2, /**< Week 1 starts Jan 1st ends day before first Week Start Day in year */
        SimpleWeek        =  3  /**< Week 1 starts Jan 1st ends after 7 days */
    };

    enum DateTimeFormatStandard {
        KdeFormat,        /**< KDE Standard */
        PosixFormat,      /**< POSIX Standard */
        UnicodeFormat     /**< UNICODE Standard (Qt/Java/OSX/Windows) */
    };

    enum DateTimeParseMode {
        LiberalParsing   /**< Parse Date/Time liberally.  So long as the
                            input string contains at least a reconizable
                            month and day the input will be accepted. */
        //ModerateParsing, /**< Parse Date/Time with modeate tolerance.
        //                      The date components in the format must all
        //                      occur in the input and in the same order,
        //                      but the spacing and the componants themselves
        //                      may vary from the strict format. */
        //StrictParsing    /**< Parse Date/Time strictly to the format. */
    };

    enum DateTimeComponent {
        Year          = 0x1,        /**< The Year portion of a date, may be number or name */
        YearName      = 0x2,        /**< The Year Name portion of a date */
        Month         = 0x4,        /**< The Month portion of a date, may be number or name */
        MonthName     = 0x8,        /**< The Month Name portion of a date */
        Day           = 0x10,       /**< The Day portion of a date, may be number or name */
        DayName       = 0x20,       /**< The Day Name portion of a date */
        JulianDay     = 0x40,       /**< The Julian Day of a date */
        EraName       = 0x80,       /**< The Era Name portion of a date */
        EraYear       = 0x100,      /**< The Era and Year portion of a date */
        YearInEra     = 0x200,      /**< The Year In Era portion of a date */
        DayOfYear     = 0x400,      /**< The Day Of Year portion of a date, may be number or name */
        DayOfYearName = 0x800,      /**< The Day Of Year Name portion of a date */
        DayOfWeek     = 0x1000,     /**< The Day Of Week / Weekday portion of a date, may be number or name */
        DayOfWeekName = 0x2000,     /**< The Day Of Week Name / Weekday Name portion of a date */
        Week          = 0x4000,     /**< The Week Number portion of a date */
        WeekYear      = 0x8000,     /**< The Week Year portion of a date */
        MonthsInYear  = 0x10000,    /**< The Months In Year portion of a date */
        WeeksInYear   = 0x20000,    /**< The Weeks In Year portion of a date */
        DaysInYear    = 0x40000,    /**< The Days In Year portion of a date */
        DaysInMonth   = 0x80000,    /**< The Days In Month portion of a date */
        DaysInWeek    = 0x100000,   /**< The Days In Week portion of a date */
        Hour          = 0x200000,   /**< The Hours portion of a date */
        Minute        = 0x400000,   /**< The Minutes portion of a date */
        Second        = 0x800000,   /**< The Seconds portion of a date */
        Millisecond   = 0x1000000,  /**< The Milliseconds portion of a date */
        DayPeriod     = 0x2000000,  /**< The Day Period portion of a date, e.g. AM/PM */
        DayPeriodHour = 0x4000000,  /**< The Day Period Hour portion of a date */
        Timezone      = 0x8000000,  /**< The Time Zone portion of a date, may be offset or name */
        TimezoneName  = 0x10000000, /**< The Time Zone Name portion of a date */
        UnixTime      = 0x20000000  /**< The UNIX Time portion of a date */
    };
    Q_DECLARE_FLAGS(DateTimeComponents, DateTimeComponent)

    enum DateTimeComponentFormat {
        DefaultComponentFormat = -1, /**< The system locale default for the componant */
        ShortNumber = 0,             /**< Number at its natural width, e.g. 2 for the 2nd*/
        LongNumber,                  /**< Number padded to a required width, e.g. 02 for the 2nd*/
        //OrdinalNumber                /**< Ordinal number format, e.g. "2nd" for the 2nd */
        NarrowName = 3,              /**< Narrow text format, may not be unique, e.g. M for Monday */
        ShortName,                   /**< Short text format, e.g. Mon for Monday */
        LongName                     /**< Long text format, e.g. Monday for Monday */
    };

    enum DateFormat {
        ShortDate,        /**< Locale Short date format, e.g. 08-04-2007 */
        LongDate,         /**< Locale Long date format, e.g. Sunday 08 April 2007 */
        FancyShortDate,   /**< Same as ShortDate for dates a week or more ago. For more
                            recent dates, it is represented as Today, Yesterday, or
                            the weekday name. */
        FancyLongDate,    /**< Same as LongDate for dates a week or more ago. For more
                            recent dates, it is represented as Today, Yesterday, or
                            the weekday name. */
        IsoDate,          /**< ISO-8601 Date format YYYY-MM-DD, e.g. 2009-12-31 */
        IsoWeekDate,      /**< ISO-8601 Week Date format YYYY-Www-D, e.g. 2009-W01-1 */
        IsoOrdinalDate    /**< ISO-8601 Ordinal Date format YYYY-DDD, e.g. 2009-001 */
    };

    QString formatDate(const QDate &date, DateFormat format = LongDate) const
    {
        switch (format) {
        case FancyShortDate:
        case ShortDate: return date.toString(Qt::SystemLocaleShortDate);
        case FancyLongDate:
        case LongDate: return date.toString(Qt::SystemLocaleLongDate);
        case IsoWeekDate:
        case IsoOrdinalDate:
        case IsoDate: break;
        }
        return date.toString(Qt::ISODate);
    }

    QString formatDate(const QDate &date, const QString &format) const { return date.toString(format); }

    QString formatDate(const QDate &date, DateTimeComponent component) const
    {
        switch (component) {
            case Year: return QString::number(date.year());
        case YearName: return QString::number(date.year());
        case Month: return QString::number(date.month());
        case MonthName: return QString::number(date.month());
        case Day: return QString::number(date.day());
        case DayName: return QString::number(date.day());
        case JulianDay: return QString::number(date.toJulianDay());
        case EraName:
        case EraYear:
        case YearInEra:
            break;
        case DayOfYear: return QString::number(date.dayOfYear());
        case DayOfYearName: return QString::number(date.dayOfYear());
        case DayOfWeek: return QString::number(date.dayOfWeek());
        case DayOfWeekName: return QString::number(date.dayOfWeek());
        case Week: return QString::number(date.weekNumber());
        case WeekYear: return QString::number(date.weekNumber());
        case MonthsInYear: return QString::number(12);
        case WeeksInYear: return QString::number(53);
        case DaysInYear: return QString::number(date.daysInYear());
        case DaysInMonth: return QString::number(date.daysInMonth());
        case DaysInWeek: return QString::number(7);
        case Hour:
        case Minute:
        case Second:
        case Millisecond:
        case DayPeriod:
        case DayPeriodHour:
        case Timezone:
        case TimezoneName:
        case UnixTime:
            break;
        }
        return QString();
    }

    QString formatDateTime(const QDateTime &dateTime, DateFormat format = ShortDate, bool includeSecs = false) const
    {
        switch (format) {
        case FancyShortDate:
        case ShortDate: return dateTime.toString(Qt::SystemLocaleShortDate);
        case FancyLongDate:
        case LongDate: return dateTime.toString(Qt::SystemLocaleLongDate);
        case IsoWeekDate:
        case IsoOrdinalDate:
        case IsoDate: break;
        }
        return dateTime.toString(Qt::ISODate);
    }
    QString formatDateTime(const QDateTime &dateTime, const QString &format) const { return dateTime.toString(format); }

    enum DateTimeFormatOption {
        TimeZone = 0x01,    /**< Include a time zone string */
        Seconds  = 0x02     /**< Include the seconds value */
    };
    Q_DECLARE_FLAGS(DateTimeFormatOptions, DateTimeFormatOption)

    QString formatDateTime(const KDateTime &dateTime, DateFormat format = ShortDate, DateTimeFormatOptions options = 0) const
    {
          switch (format) {
          case FancyShortDate:
          case ShortDate: return dateTime.toString(Qt::SystemLocaleShortDate);
          case FancyLongDate:
          case LongDate: return dateTime.toString(Qt::SystemLocaleLongDate);
          case IsoWeekDate:
          case IsoOrdinalDate:
          case IsoDate: break;
          }
          return dateTime.toString(Qt::ISODate);
    }

#if 0
    /**
    * Use this to determine whether in dates a possessive form of month
    * name is preferred ("of January" rather than "January")
    *
    * @return If possessive form should be used
    */
    bool dateMonthNamePossessive() const;
#endif

    QString formatTime(const QTime &pTime, bool includeSecs = false, bool isDuration = false) const
    {
        return m_locale.toString(pTime);
    }

    enum TimeFormatOption { TimeDefault = 0x0, TimeWithoutSeconds = 0x1, TimeWithoutAmPm    = 0x2, TimeDuration       = 0x6,  TimeFoldHours      = 0xE };
    Q_DECLARE_FLAGS(TimeFormatOptions, TimeFormatOption)

    QString formatLocaleTime(const QTime &pTime, TimeFormatOptions options = KLocale::TimeDefault) const
        { return m_locale.toString(pTime); }

#if 0
    /**
    * @since 4.3
    *
    * Returns the identifier of the digit set used to display dates and time.
    *
    * @return the digit set identifier
    * @see DigitSet
    * @see digitSetToName
    */
    DigitSet dateTimeDigitSet() const;

    /**
    * Use this to determine if the user wants a 12 hour clock.
    *
    * @return If the user wants 12h clock
    */
    bool use12Clock() const;

    /**
    * @since 4.6
    *
    * Returns the Day Period matching the time given
    *
    * @param time the time to return the day period for
    * @param format the format to return teh day period in
    * @return the Day Period for the given time
    */
    QString dayPeriodText(const QTime &time, DateTimeComponentFormat format = DefaultComponentFormat) const;
#endif

    int weekStartDay() const { return m_locale.firstDayOfWeek(); }
    int workingWeekStartDay() const { return Qt::Monday; }
    int workingWeekEndDay() const { return Qt::Friday; }
    int weekDayOfPray() const { return Qt::Sunday; }

    const KCalendarSystem* calendar() const { return m_calendar; }

#if 0
    //KDE_DEPRECATED QString calendarType() const;
    KLocale::CalendarSystem calendarSystem() const;
    //KDE_DEPRECATED void setCalendar(const QString & calendarType);
    void setCalendarSystem(KLocale::CalendarSystem calendarSystem);

    /**
    * @since 4.6
    *
    * Sets the type of Week Number System to use in this Locale
    *
    * @see Klocale::WeekNumberSystem
    * @see weekNumberSystem()
    * @param weekNumberSystem the Week Number System to use
    */
    void setWeekNumberSystem(KLocale::WeekNumberSystem weekNumberSystem);

    //KDE5 remove in favour of const version
    /**
    * @since 4.6
    *
    * Returns the type of Week Number System used in this Locale
    *
    * @see Klocale::WeekNumberSystem
    * @see setWeekNumberSystem()
    * @returns the Week Number System used
    */
    KLocale::WeekNumberSystem weekNumberSystem();

    /**
    * @since 4.7
    *
    * Returns the type of Week Number System used in this Locale
    *
    * @see Klocale::WeekNumberSystem
    * @see setWeekNumberSystem()
    * @returns the Week Number System used
    */
    KLocale::WeekNumberSystem weekNumberSystem() const;
#endif

    double readMoney(const QString &numStr, bool * ok = 0) const
    {
        QString s = numStr;
        s.remove(m_locale.currencySymbol());
        //s.remove(m_locale.groupSeparator());
        return s.toDouble(ok);
    }

    QDate readDate(const QString &str, bool* ok = 0) const
    {
        QDate date = QDate::fromString(str);
        if (ok) *ok = date.isValid();
        return date;
    }

    QDate readDate(const QString &str, const QString &fmt, bool* ok = 0) const
    {
        QDate date = QDate::fromString(str, fmt);
        if (ok) *ok = date.isValid();
        return date;
    }

    enum ReadDateFlags { NormalFormat = 1, ShortFormat = 2, IsoFormat = 4, IsoWeekFormat = 8, IsoOrdinalFormat = 16 };
    QDate readDate(const QString &str, ReadDateFlags flags, bool *ok = 0) const
    {
        QDate date = QDate::fromString(str);
        if (ok) *ok = date.isValid();
        return date;
    }

    QTime readTime(const QString &str, bool* ok = 0) const
    {
        QTime time = QTime::fromString(str);
        if (ok) *ok = time.isValid();
        return time;
    }

    enum ReadTimeFlags { WithSeconds = 0, WithoutSeconds = 1 };
    QTime readTime(const QString &str, ReadTimeFlags flags, bool *ok = 0) const
    {
        QTime time = QTime::fromString(str);
        if (ok) *ok = time.isValid();
        return time;
    }

    enum TimeProcessingOption { ProcessStrict = 0x1, ProcessNonStrict = 0x2 };
    Q_DECLARE_FLAGS(TimeProcessingOptions, TimeProcessingOption)
    QTime readLocaleTime(const QString &str, bool *ok = 0, TimeFormatOptions options = KLocale::TimeDefault, TimeProcessingOptions processing = ProcessNonStrict) const
    {
        QTime time = QTime::fromString(str);
        if (ok) *ok = time.isValid();
        return time;
    }

    QString language() const { return QLocale::languageToString(m_locale.language()); }
    QString country() const { return QLocale::countryToString(m_locale.country()); }
    QString countryDivisionCode() const { return country(); }

    /**
    * Returns the language codes selected by user, ordered by decreasing
    * priority.
    *
    * Use languageCodeToName(language) to get human readable, localized
    * language name.
    *
    * @return list of language codes
    *
    * @see languageCodeToName
    */
    QStringList languageList() const { return QStringList() << QLocale::languageToString(m_locale.language()); }

    /**
    * @since 4.4
    *
    * Returns the ISO Currency Codes used in the locale, ordered by decreasing
    * priority.
    *
    * Use KCurrency::currencyCodeToName(currencyCode) to get human readable,
    * localized language name.
    *
    * @return list of ISO Currency Codes
    *
    * @see currencyCodeToName
    */
    QStringList currencyCodeList() const { return QStringList() << m_locale.currencySymbol(QLocale::CurrencyIsoCode); }

#if 0
    /**
    * Returns the user's preferred encoding.
    *
    * @return The name of the preferred encoding
    *
    * @see codecForEncoding
    * @see encodingMib
    */
    const QByteArray encoding() const;

    /**
    * Returns the user's preferred encoding.
    *
    * @return The Mib of the preferred encoding
    *
    * @see encoding
    * @see codecForEncoding
    */
    int encodingMib() const;

    /**
    * Returns the user's preferred encoding. Should never be NULL.
    *
    * @return The codec for the preferred encoding
    *
    * @see encoding
    * @see encodingMib
    */
    QTextCodec * codecForEncoding() const;

    /**
    * Returns the file encoding.
    *
    * @return The Mib of the file encoding
    *
    * @see QFile::encodeName
    * @see QFile::decodeName
    */
    int fileEncodingMib() const;
#endif

    QString dateFormat() const { return m_locale.dateFormat(QLocale::LongFormat); }
    QString dateFormatShort() const { return m_locale.dateFormat(QLocale::ShortFormat); }
    QString timeFormat() const { return m_locale.timeFormat(); }

    void setDateFormat(const QString & format) {}
    void setDateFormatShort(const QString & format) {}
    void setDateMonthNamePossessive(bool possessive) {}
    void setTimeFormat(const QString & format) {}
    void setDateTimeDigitSet(DigitSet digitSet) {}
    void setWeekStartDay(int day) {}
    void setWorkingWeekStartDay(int day) {}
    void setWorkingWeekEndDay(int day) {}
    void setWeekDayOfPray(int day) {}
    void setDecimalSymbol(const QString & symbol) {}
    void setThousandsSeparator(const QString & separator) {}
    void setPositiveSign(const QString & sign) {}
    void setNegativeSign(const QString & sign) {}
    void setDigitSet(DigitSet digitSet) {}
    void setPositiveMonetarySignPosition(SignPosition signpos) {}
    void setNegativeMonetarySignPosition(SignPosition signpos) {}
    void setPositivePrefixCurrencySymbol(bool prefix) {}
    void setNegativePrefixCurrencySymbol(bool prefix) {}
    //KDE_DEPRECATED void setFracDigits(int digits) {}
    void setDecimalPlaces(int digits) {}
    void setMonetaryDecimalPlaces(int digits) {}
    void setMonetaryThousandsSeparator(const QString & separator) {}
    void setMonetaryDecimalSymbol(const QString & symbol) {}
    void setCurrencyCode(const QString &newCurrencyCode) {}
    void setCurrencySymbol(const QString & symbol) {}
    void setMonetaryDigitSet(DigitSet digitSet) {}
    //int pageSize() const;
    //void setPageSize(int paperFormat);

    enum MeasureSystem { Metric, Imperial };
    MeasureSystem measureSystem() const { return Metric; }
    void setMeasureSystem(MeasureSystem value) {}

    void insertCatalog(const QString& catalog) {}
    void removeCatalog(const QString &catalog) {}
    void setActiveCatalog(const QString &catalog) {}

    QString translateQt(const char *context, const char *sourceText, const char *comment) const { return QCoreApplication::translate(context, sourceText); }

#if 0
    /**
    * Provides list of all known language codes.
    *
    * Use languageCodeToName(language) to get human readable, localized
    * language names.
    *
    * @return list of all language codes
    *
    * @see languageCodeToName
    * @see installedLanguages
    */
    QStringList allLanguagesList() const;

    /**
    * @since 4.6
    *
    * Provides list of all installed KDE Language Translations.
    *
    * Use languageCodeToName(language) to get human readable, localized
    * language names.
    *
    * @return list of all installed language codes
    *
    * @see languageCodeToName
    */
    QStringList installedLanguages() const;

    /**
    * Convert a known language code to a human readable, localized form.
    * If an unknown language code is supplied, empty string is returned;
    * this will never happen if the code has been obtained by one of the
    * KLocale methods.
    *
    * @param language the language code
    *
    * @return the human readable and localized form if the code is known,
    *         empty otherwise
    *
    * @see language
    * @see languageList
    * @see allLanguagesList
    * @see installedLanguages
    */
    QString languageCodeToName(const QString &language) const;

    /**
    * Provides list of all known country codes.
    *
    * Use countryCodeToName(country) to get human readable, localized
    * country names.
    *
    * @return a list of all country codes
    *
    * @see countryCodeToName
    */
    QStringList allCountriesList() const;

    /**
    * Convert a known country code to a human readable, localized form.
    *
    * If an unknown country code is supplied, empty string is returned;
    * this will never happen if the code has been obtained by one of the
    * KLocale methods.
    *
    * @param country the country code
    *
    * @return the human readable and localized form of the country name
    *
    * @see country
    * @see allCountriesList
    */
    QString countryCodeToName(const QString &country) const;

#endif

    /**
    * Parses locale string into distinct parts.
    * The format of locale is language_COUNTRY@modifier.CHARSET
    *
    * @param locale the locale string to split
    * @param language set to the language part of the locale
    * @param country set to the country part of the locale
    * @param modifier set to the modifer part of the locale
    * @param charset set to the charset part of the locale
    */
    static void splitLocale(const QString &locale, QString &language, QString &country,
                            QString &modifier, QString &charset);



    static void setMainCatalog(const char *catalog) {}

#if 0
    /**
    * @deprecated
    *
    * Finds localized resource in resourceDir( rtype ) + \<lang> + fname.
    *
    * Since KDE 4.1, this service is provided in a slightly different form,
    * automatically by e.g. KStandardDirs::locate() and other KDE core classes
    * dealing with paths. For manual use, it is replaced by localizedFilePath().
    *
    * @param fname relative path to find
    * @param rtype resource type to use
    *
    * @return path to localized resource
    *
    * @see localizedFilePath
    */
    static QString langLookup(const QString &fname, const char *rtype = "html");

    /**
    * Returns the name of the internal language.
    *
    * @return Name of the default language
    */
    static QString defaultLanguage();

    /**
    * Returns the code of the default country, i.e. "C"
    *
    * This function will not provide a sensible value to use in your app,
    * please use country() instead.
    *
    * @see country
    *
    * @return Name of the default country
    */
    static QString defaultCountry();

    /**
    * @since 4.4
    *
    * Returns the ISO Code of the default currency.
    *
    * @return ISO Currency Code of the default currency
    */
    static QString defaultCurrencyCode();

    /**
    * Reports whether evaluation of translation scripts is enabled.
    *
    * @return true if script evaluation is enabled, false otherwise.
    */
    bool useTranscript() const;

    /**
    * Checks whether or not the active catalog is found for the given language.
    *
    * @param language language to check
    */
    bool isApplicationTranslatedInto(const QString & language);

    /**
    * Copies the catalogs of this object to an other KLocale object.
    *
    * @param locale the destination KLocale object
    */
    void copyCatalogsTo(KLocale *locale);

    /**
    * Changes the current country. The current country will be left
    * unchanged if failed. It will force a reload of the country specific
    * configuration.
    *
    * An empty country value will set the country to the system default.
    *
    * If you specify a configuration file, a setLocale() will be performed on
    * the config using the current locale language, which may cause a sync()
    * and reparseConfiguration() which will save any changes you have made.
    *
    * @param country the ISO 3166 country code
    * @param config  a configuration file with a Locale group detailing
    *                locale-related preferences (such as language and
    *                formatting options).
    *
    * @return @c true on success, @c false on failure
    */
    bool setCountry(const QString & country, KConfig *config);

    /**
    * @since 4.6
    *
    * Sets the Country Division Code of the Country where the user lives.
    *
    * The code must comply with the ISO 3166-2 standard.
    * See http://en.wikipedia.org/wiki/ISO_3166-2 for details.
    *
    * In KDE 4.6 it is the apps responsibility to validate the input,
    * full validation and other services will be provided in KDE 4.7.
    *
    * @param countryDivision the Country Division Code for the user
    * @return @c true on success, @c false on failure
    * @see countryDivisionCode
    */
    bool setCountryDivisionCode(const QString & countryDivision);

    /**
    * Changes the current language. The current language will be left
    * unchanged if failed. It will force a reload of the country specific
    * configuration as well.
    *
    * If you specify a configuration file, a setLocale() will be performed on
    * the config using the current locale language, which may cause a sync()
    * and reparseConfiguration() which will save any changes you have made.
    *
    * @param language the language code
    * @param config   a configuration file with a Locale group detailing
    *                 locale-related preferences (such as language and
    *                 formatting options).
    *
    * @return true on success
    */
    bool setLanguage(const QString &language, KConfig *config);

    /**
    * Changes the list of preferred languages for the locale. The first valid
    * language in the list will be used, or the default language (en_US)
    * if none of the specified languages were available.
    *
    * @param languages the list of language codes
    *
    * @return true if one of the specified languages were used
    */
    bool setLanguage(const QStringList &languages);
#endif

    QString localizedFilePath(const QString &filePath) const { return filePath; }

#if 0
    /**
    * @since 4.2
    *
    * Removes accelerator marker from a UI text label.
    *
    * Accelerator marker is not always a plain ampersand (&),
    * so it is not enough to just remove it by @c QString::remove().
    * The label may contain escaped markers ("&&") which must be resolved
    * and skipped, as well as CJK-style markers ("Foo (&F)") where
    * the whole parenthesis construct should be removed.
    * Therefore always use this function to remove accelerator marker
    * from UI labels.
    *
    * @param label UI label which may contain an accelerator marker
    * @return label without the accelerator marker
    */
    QString removeAcceleratorMarker(const QString &label) const;

    /**
    * @since 4.3
    *
    * Convert all digits in the string to the given digit set.
    *
    * Conversion is normally not performed if the given digit set
    * is not appropriate in the current locale and language context.
    * Unconditional conversion may be requested by setting
    * @p ignoreContext to @c true.
    *
    * @param str the string to convert
    * @param digitSet the digit set identifier
    * @param ignoreContext unconditional conversion if @c true
    *
    * @return string with converted digits
    *
    * @see DigitSet
    */
    QString convertDigits(const QString &str, DigitSet digitSet,
                        bool ignoreContext = false) const;

    /**
    * @since 4.8
    *
    * Reparse locale configuration files for the current selected
    * language.
    */
    void reparseConfiguration();
#endif

private:
    QLocale m_locale;
    KCalendarSystem *m_calendar;
};
#if 0
/**
 * Qt's uic generated translation calls go through numerous indirections
 * unnecessary in our case. So we use <tt>uic -tr tr2i18n</tt> to redirect them
 * to ki18n API.
**/
inline QString tr2i18n (const char *message, const char *comment = 0) {
    if (comment && comment[0] && message && message[0]) {
        return ki18nc(comment, message).toString();
    }
    else if (message && message[0]) {
        return ki18n(message).toString();
    }
    else {
        return QString();
    }
}
#endif
#endif
